// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Deno from "../bindings/Deno.res.js";
import * as Adapter from "../Adapter.res.js";
import * as Stdlib_Exn from "@rescript/runtime/lib/es6/Stdlib_Exn.js";

let baseUrl = {
  contents: $$Deno.Env.getWithDefault("LOKI_URL", "http://localhost:3100")
};

let connected = {
  contents: false
};

async function connect() {
  let url = baseUrl.contents + "/ready";
  let e = await $$Deno.Fetch.get(url, undefined);
  if (e.TAG === "Ok") {
    connected.contents = true;
    return;
  } else {
    return Stdlib_Exn.raiseError(`Failed to connect to Loki: ` + e._0);
  }
}

async function disconnect() {
  connected.contents = false;
}

async function isConnected() {
  return connected.contents;
}

async function queryHandler(args) {
  let match = args["query"];
  let query = typeof match === "string" ? match : Stdlib_Exn.raiseError("query parameter is required");
  let match$1 = args["limit"];
  let limit = typeof match$1 === "number" ? match$1 | 0 : 100;
  let match$2 = args["time"];
  let time = typeof match$2 === "string" ? match$2 : undefined;
  let url = time !== undefined ? baseUrl.contents + `/loki/api/v1/query?query=` + query + `&limit=` + limit.toString() + `&time=` + time : baseUrl.contents + `/loki/api/v1/query?query=` + query + `&limit=` + limit.toString();
  let data = await $$Deno.Fetch.get(url, undefined);
  if (data.TAG === "Ok") {
    return data._0;
  } else {
    return Stdlib_Exn.raiseError(data._0);
  }
}

async function queryRangeHandler(args) {
  let match = args["query"];
  let query = typeof match === "string" ? match : Stdlib_Exn.raiseError("query parameter is required");
  let match$1 = args["start"];
  let start = typeof match$1 === "string" ? match$1 : Stdlib_Exn.raiseError("start parameter is required");
  let match$2 = args["end"];
  let end_ = typeof match$2 === "string" ? match$2 : Stdlib_Exn.raiseError("end parameter is required");
  let match$3 = args["limit"];
  let limit = typeof match$3 === "number" ? match$3 | 0 : 100;
  let match$4 = args["direction"];
  let direction = typeof match$4 === "string" ? match$4 : "backward";
  let url = baseUrl.contents + `/loki/api/v1/query_range?query=` + query + `&start=` + start + `&end=` + end_ + `&limit=` + limit.toString() + `&direction=` + direction;
  let data = await $$Deno.Fetch.get(url, undefined);
  if (data.TAG === "Ok") {
    return data._0;
  } else {
    return Stdlib_Exn.raiseError(data._0);
  }
}

async function labelsHandler(args) {
  let match = args["start"];
  let start = typeof match === "string" ? match : undefined;
  let match$1 = args["end"];
  let end_ = typeof match$1 === "string" ? match$1 : undefined;
  let url = start !== undefined ? (
      end_ !== undefined ? baseUrl.contents + `/loki/api/v1/labels?start=` + start + `&end=` + end_ : baseUrl.contents + `/loki/api/v1/labels`
    ) : baseUrl.contents + `/loki/api/v1/labels`;
  let data = await $$Deno.Fetch.get(url, undefined);
  if (data.TAG === "Ok") {
    return data._0;
  } else {
    return Stdlib_Exn.raiseError(data._0);
  }
}

async function labelValuesHandler(args) {
  let match = args["label"];
  let label = typeof match === "string" ? match : Stdlib_Exn.raiseError("label parameter is required");
  let match$1 = args["start"];
  let start = typeof match$1 === "string" ? match$1 : undefined;
  let match$2 = args["end"];
  let end_ = typeof match$2 === "string" ? match$2 : undefined;
  let url;
  let exit = 0;
  if (start !== undefined && end_ !== undefined) {
    url = baseUrl.contents + `/loki/api/v1/label/` + label + `/values?start=` + start + `&end=` + end_;
  } else {
    exit = 1;
  }
  if (exit === 1) {
    url = baseUrl.contents + `/loki/api/v1/label/` + label + `/values`;
  }
  let data = await $$Deno.Fetch.get(url, undefined);
  if (data.TAG === "Ok") {
    return data._0;
  } else {
    return Stdlib_Exn.raiseError(data._0);
  }
}

async function seriesHandler(args) {
  let match = args["match"];
  let match_ = typeof match === "string" ? match : Stdlib_Exn.raiseError("match parameter is required");
  let match$1 = args["start"];
  let start = typeof match$1 === "string" ? match$1 : undefined;
  let match$2 = args["end"];
  let end_ = typeof match$2 === "string" ? match$2 : undefined;
  let url;
  let exit = 0;
  if (start !== undefined && end_ !== undefined) {
    url = baseUrl.contents + `/loki/api/v1/series?match[]=` + match_ + `&start=` + start + `&end=` + end_;
  } else {
    exit = 1;
  }
  if (exit === 1) {
    url = baseUrl.contents + `/loki/api/v1/series?match[]=` + match_;
  }
  let data = await $$Deno.Fetch.get(url, undefined);
  if (data.TAG === "Ok") {
    return data._0;
  } else {
    return Stdlib_Exn.raiseError(data._0);
  }
}

async function tailHandler(args) {
  let match = args["query"];
  let query = typeof match === "string" ? match : Stdlib_Exn.raiseError("query parameter is required");
  let match$1 = args["limit"];
  let limit = typeof match$1 === "number" ? match$1 | 0 : 10;
  let match$2 = args["delayFor"];
  let delayFor = typeof match$2 === "number" ? match$2 | 0 : 0;
  let url = baseUrl.contents + `/loki/api/v1/tail?query=` + query + `&limit=` + limit.toString() + `&delay_for=` + delayFor.toString();
  let data = await $$Deno.Fetch.get(url, undefined);
  if (data.TAG === "Ok") {
    return data._0;
  } else {
    return Stdlib_Exn.raiseError(data._0);
  }
}

async function indexStatsHandler(args) {
  let match = args["query"];
  let query = typeof match === "string" ? match : undefined;
  let match$1 = args["start"];
  let start = typeof match$1 === "string" ? match$1 : undefined;
  let match$2 = args["end"];
  let end_ = typeof match$2 === "string" ? match$2 : undefined;
  let params = [];
  if (query !== undefined) {
    params.push(`query=` + query);
  }
  if (start !== undefined) {
    params.push(`start=` + start);
  }
  if (end_ !== undefined) {
    params.push(`end=` + end_);
  }
  let queryString = params.join("&");
  let url = queryString !== "" ? baseUrl.contents + `/loki/api/v1/index/stats?` + queryString : baseUrl.contents + `/loki/api/v1/index/stats`;
  let data = await $$Deno.Fetch.get(url, undefined);
  if (data.TAG === "Ok") {
    return data._0;
  } else {
    return Stdlib_Exn.raiseError(data._0);
  }
}

let tools = Object.fromEntries([
  [
    "loki_query",
    {
      description: "Execute an instant LogQL query",
      params: Object.fromEntries([
        [
          "query",
          Adapter.stringParam("LogQL query expression")
        ],
        [
          "limit",
          Adapter.numberParam("Maximum number of entries to return (default 100)")
        ],
        [
          "time",
          Adapter.stringParam("Evaluation timestamp (RFC3339 or Unix nanoseconds)")
        ]
      ]),
      handler: queryHandler
    }
  ],
  [
    "loki_query_range",
    {
      description: "Execute a range LogQL query",
      params: Object.fromEntries([
        [
          "query",
          Adapter.stringParam("LogQL query expression")
        ],
        [
          "start",
          Adapter.stringParam("Start timestamp (RFC3339 or Unix nanoseconds)")
        ],
        [
          "end",
          Adapter.stringParam("End timestamp (RFC3339 or Unix nanoseconds)")
        ],
        [
          "limit",
          Adapter.numberParam("Maximum number of entries (default 100)")
        ],
        [
          "direction",
          Adapter.stringParam("Log order: forward or backward (default backward)")
        ]
      ]),
      handler: queryRangeHandler
    }
  ],
  [
    "loki_labels",
    {
      description: "List all label names",
      params: Object.fromEntries([
        [
          "start",
          Adapter.stringParam("Start timestamp (optional)")
        ],
        [
          "end",
          Adapter.stringParam("End timestamp (optional)")
        ]
      ]),
      handler: labelsHandler
    }
  ],
  [
    "loki_label_values",
    {
      description: "List values for a specific label",
      params: Object.fromEntries([
        [
          "label",
          Adapter.stringParam("Label name")
        ],
        [
          "start",
          Adapter.stringParam("Start timestamp (optional)")
        ],
        [
          "end",
          Adapter.stringParam("End timestamp (optional)")
        ]
      ]),
      handler: labelValuesHandler
    }
  ],
  [
    "loki_series",
    {
      description: "List log streams matching a selector",
      params: Object.fromEntries([
        [
          "match",
          Adapter.stringParam("Series selector (e.g., {job=\"varlogs\"})")
        ],
        [
          "start",
          Adapter.stringParam("Start timestamp (optional)")
        ],
        [
          "end",
          Adapter.stringParam("End timestamp (optional)")
        ]
      ]),
      handler: seriesHandler
    }
  ],
  [
    "loki_tail",
    {
      description: "Get recent logs (snapshot of tail)",
      params: Object.fromEntries([
        [
          "query",
          Adapter.stringParam("LogQL query expression")
        ],
        [
          "limit",
          Adapter.numberParam("Maximum number of entries (default 10)")
        ],
        [
          "delayFor",
          Adapter.numberParam("Delay in seconds before fetching")
        ]
      ]),
      handler: tailHandler
    }
  ],
  [
    "loki_index_stats",
    {
      description: "Get index statistics",
      params: Object.fromEntries([
        [
          "query",
          Adapter.stringParam("LogQL query (optional)")
        ],
        [
          "start",
          Adapter.stringParam("Start timestamp (optional)")
        ],
        [
          "end",
          Adapter.stringParam("End timestamp (optional)")
        ]
      ]),
      handler: indexStatsHandler
    }
  ]
]);

let name = "loki";

let description = "Loki log aggregation adapter";

export {
  baseUrl,
  connected,
  name,
  description,
  connect,
  disconnect,
  isConnected,
  queryHandler,
  queryRangeHandler,
  labelsHandler,
  labelValuesHandler,
  seriesHandler,
  tailHandler,
  indexStatsHandler,
  tools,
}
/* baseUrl Not a pure module */
