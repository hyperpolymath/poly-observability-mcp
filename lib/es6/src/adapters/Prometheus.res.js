// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Deno from "../bindings/Deno.res.js";
import * as Adapter from "../Adapter.res.js";
import * as Stdlib_Exn from "@rescript/runtime/lib/es6/Stdlib_Exn.js";

let baseUrl = {
  contents: $$Deno.Env.getWithDefault("PROMETHEUS_URL", "http://localhost:9090")
};

let connected = {
  contents: false
};

async function connect() {
  let url = baseUrl.contents + "/api/v1/status/buildinfo";
  let e = await $$Deno.Fetch.get(url, undefined);
  if (e.TAG === "Ok") {
    connected.contents = true;
    return;
  } else {
    return Stdlib_Exn.raiseError(`Failed to connect to Prometheus: ` + e._0);
  }
}

async function disconnect() {
  connected.contents = false;
}

async function isConnected() {
  return connected.contents;
}

async function queryHandler(args) {
  let match = args["query"];
  let query = typeof match === "string" ? match : Stdlib_Exn.raiseError("query parameter is required");
  let match$1 = args["time"];
  let time = typeof match$1 === "string" ? match$1 : undefined;
  let url = time !== undefined ? baseUrl.contents + `/api/v1/query?query=` + query + `&time=` + time : baseUrl.contents + `/api/v1/query?query=` + query;
  let data = await $$Deno.Fetch.get(url, undefined);
  if (data.TAG === "Ok") {
    return data._0;
  } else {
    return Stdlib_Exn.raiseError(data._0);
  }
}

async function queryRangeHandler(args) {
  let match = args["query"];
  let query = typeof match === "string" ? match : Stdlib_Exn.raiseError("query parameter is required");
  let match$1 = args["start"];
  let start = typeof match$1 === "string" ? match$1 : Stdlib_Exn.raiseError("start parameter is required");
  let match$2 = args["end"];
  let end_ = typeof match$2 === "string" ? match$2 : Stdlib_Exn.raiseError("end parameter is required");
  let match$3 = args["step"];
  let step = typeof match$3 === "string" ? match$3 : "15s";
  let url = baseUrl.contents + `/api/v1/query_range?query=` + query + `&start=` + start + `&end=` + end_ + `&step=` + step;
  let data = await $$Deno.Fetch.get(url, undefined);
  if (data.TAG === "Ok") {
    return data._0;
  } else {
    return Stdlib_Exn.raiseError(data._0);
  }
}

async function seriesHandler(args) {
  let match = args["match"];
  let match_ = typeof match === "string" ? match : Stdlib_Exn.raiseError("match parameter is required");
  let url = baseUrl.contents + `/api/v1/series?match[]=` + match_;
  let data = await $$Deno.Fetch.get(url, undefined);
  if (data.TAG === "Ok") {
    return data._0;
  } else {
    return Stdlib_Exn.raiseError(data._0);
  }
}

async function labelsHandler(_args) {
  let url = baseUrl.contents + `/api/v1/labels`;
  let data = await $$Deno.Fetch.get(url, undefined);
  if (data.TAG === "Ok") {
    return data._0;
  } else {
    return Stdlib_Exn.raiseError(data._0);
  }
}

async function labelValuesHandler(args) {
  let match = args["label"];
  let label = typeof match === "string" ? match : Stdlib_Exn.raiseError("label parameter is required");
  let url = baseUrl.contents + `/api/v1/label/` + label + `/values`;
  let data = await $$Deno.Fetch.get(url, undefined);
  if (data.TAG === "Ok") {
    return data._0;
  } else {
    return Stdlib_Exn.raiseError(data._0);
  }
}

async function targetsHandler(_args) {
  let url = baseUrl.contents + `/api/v1/targets`;
  let data = await $$Deno.Fetch.get(url, undefined);
  if (data.TAG === "Ok") {
    return data._0;
  } else {
    return Stdlib_Exn.raiseError(data._0);
  }
}

async function alertsHandler(_args) {
  let url = baseUrl.contents + `/api/v1/alerts`;
  let data = await $$Deno.Fetch.get(url, undefined);
  if (data.TAG === "Ok") {
    return data._0;
  } else {
    return Stdlib_Exn.raiseError(data._0);
  }
}

async function rulesHandler(_args) {
  let url = baseUrl.contents + `/api/v1/rules`;
  let data = await $$Deno.Fetch.get(url, undefined);
  if (data.TAG === "Ok") {
    return data._0;
  } else {
    return Stdlib_Exn.raiseError(data._0);
  }
}

let tools = Object.fromEntries([
  [
    "prometheus_query",
    {
      description: "Execute an instant PromQL query",
      params: Object.fromEntries([
        [
          "query",
          Adapter.stringParam("PromQL query expression")
        ],
        [
          "time",
          Adapter.stringParam("Evaluation timestamp (RFC3339 or Unix timestamp)")
        ]
      ]),
      handler: queryHandler
    }
  ],
  [
    "prometheus_query_range",
    {
      description: "Execute a range PromQL query",
      params: Object.fromEntries([
        [
          "query",
          Adapter.stringParam("PromQL query expression")
        ],
        [
          "start",
          Adapter.stringParam("Start timestamp (RFC3339 or Unix)")
        ],
        [
          "end",
          Adapter.stringParam("End timestamp (RFC3339 or Unix)")
        ],
        [
          "step",
          Adapter.stringParam("Query step (e.g., 15s, 1m)")
        ]
      ]),
      handler: queryRangeHandler
    }
  ],
  [
    "prometheus_series",
    {
      description: "List time series matching a selector",
      params: Object.fromEntries([[
          "match",
          Adapter.stringParam("Series selector (e.g., up{job=\"prometheus\"})")
        ]]),
      handler: seriesHandler
    }
  ],
  [
    "prometheus_labels",
    {
      description: "List all label names",
      params: {},
      handler: labelsHandler
    }
  ],
  [
    "prometheus_label_values",
    {
      description: "List values for a specific label",
      params: Object.fromEntries([[
          "label",
          Adapter.stringParam("Label name")
        ]]),
      handler: labelValuesHandler
    }
  ],
  [
    "prometheus_targets",
    {
      description: "Get current scrape targets and their status",
      params: {},
      handler: targetsHandler
    }
  ],
  [
    "prometheus_alerts",
    {
      description: "Get current active alerts",
      params: {},
      handler: alertsHandler
    }
  ],
  [
    "prometheus_rules",
    {
      description: "Get alerting and recording rules",
      params: {},
      handler: rulesHandler
    }
  ]
]);

let name = "prometheus";

let description = "Prometheus metrics server adapter";

export {
  baseUrl,
  connected,
  name,
  description,
  connect,
  disconnect,
  isConnected,
  queryHandler,
  queryRangeHandler,
  seriesHandler,
  labelsHandler,
  labelValuesHandler,
  targetsHandler,
  alertsHandler,
  rulesHandler,
  tools,
}
/* baseUrl Not a pure module */
